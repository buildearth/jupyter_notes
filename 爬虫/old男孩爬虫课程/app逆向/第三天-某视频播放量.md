# 需求

这个视频是只有app端，没有网页端，但是app端的视频可以分析连接，在网页端打开并播放，此时在网页上播放也会增加播放量，所以可以在网页端进行分析并且刷播放量。

需要注意的是，网页上只能播放当前分析连接的视频，如果点击分析的网页打开的其他视频时，是无法播放的。

所以每次刷新的视频播放量，必须是经过app分享出来的。

需要使用js代码进行播放量的增加，不过效果比较滞后，在网页上刷完之后需要五六分钟之后才能看到效果。在浏览器上不是实时展示的，不过在app上会更快展示出效果。

# 抓包和任务分解

拿到这个视频的连接，一点播放看看都发送了哪些请求，发送的每一个请求都有可能是用来增加播放量的请求，要找到正确的请求就需要一个一个去尝试，一个请求模拟好后发送个几百次来看效果。

## 请求分析

网页端播放视频的操作：

- 自己下载`y a n g`视频的app
- 打开app，找到一个视频，点击分析拿到连接
- 在网页端打开这个链接，就可以播放分析的视频了，并进行分析

拷贝链接到无痕浏览器打开，清空请求，然后点击播放，一点播放出来下面几个请求

![image-20220706222231659](.\asset3\image-20220706222231659.png)

分析每一个请求：

1. 第一个请求是获取了一个动图

2. 是下载当前视频的一个网址，可以拷贝链接在浏览器打开

   ![image-20220706224309511](.\asset3\image-20220706224309511.png)

3. 第三个是一个图片

   ![image-20220706224353176](.\asset3\image-20220706224353176.png)

4. 第四五六七个请求作用不知道，但是传递的参数挺多的

5. 第八个请求不清楚作用



上面的请求中，你觉得哪个请求更像是增长播放量的？

```
每个请求都有可能是增长播放量的，但是其是增长播放量的可能性是不一样的，有大有小。

很多网站为了干扰，都会加一些套路，有些网站会在请求gif图片数据时做一些骚操作，不过可能性不大，一般网站都是正常的。

一般情况下，图片资源，视频资源不会和增长播放量的功能结合在一起，一个请求同时获取资源且增长播放量。

一般静态资源资源都会放在文件服务器中(cdn)，如果网页想获取静态资源，就会去文件服务器获取。将处理业务逻辑的服务器和静态资源的服务器划分，这样就会将处理业务逻辑的服务器压力减轻，所以一般情况下静态资源的请求不会影响到业务逻辑。

逆向过程中，一般看到`gif, mp4, png`都可以略过，这些都是单纯的媒体资源。但是不要忽视这些请求，也有可能会有业务逻辑伴随着，不过可能性小（有些网站可能在返回媒体资源时，会返回cookie信息，如果忽视，就会有大问题）。

所以分析下来，按照简单逻辑，可能性由大到小排序
    1. kvcollect  请求四五六，这个请求中携带了很多数据，先分析请求四五六
    2. 静态资源请求
    3. 其他请求
简单逻辑的请求分析顺序：
    先模拟请求四五六，如果请求没有增长。然后从上往下分析静态资源的请求（请求一二三）进行模拟，再看有没有增长
    如果还没有增长，就挨个再去分析后面的请求进行模拟观测。
    
复杂逻辑就是：
	从上到下，挨个分析请求，进行模拟多次看结果。
```



## 具体请求的分析

第一分析的请求选择`https://btrace.yangshipin.cn/kvcollect?BossId=2865`

一般按照，请求URL，请求参数，cookie，请求头的顺序来进行分析。



分析过程中，多换几个浏览器，多换几个视频，刷新播放几次观察，刷新时注意清空cookie。

### url

url中有BossId这个参数，经过测试是不变的，固定值

### 请求参数

从页面拷贝的浏览器参数

```
ctime: 2022-07-10 15:32:04
ua: mozilla/5.0 (windows nt 10.0; win64; x64) applewebkit/537.36 (khtml, like gecko) chrome/103.0.0.0 safari/537.36
hh_ua: mozilla/5.0 (windows nt 10.0; win64; x64) applewebkit/537.36 (khtml, like gecko) chrome/103.0.0.0 safari/537.36
platform: 4330701
guid: l5ezz8nc_551u1jgumk7
Pwd: 1698957057
version: wc-1.2.6
url: https://w.yangshipin.cn/video?type=0&vid=y000097sc9z
hh_ref: https://w.yangshipin.cn/video?type=0&vid=y000097sc9z
vid: y000097sc9z
isfocustab: 1
isvisible: 1
idx: 0
val: 461
pid: l5ezz8xb_sk4e9vh0pzj
bi: 0
bt: 0
defn: hd
vurl: https://mp4playcloud-cdn.ysp.cctv.cn/y000097sc9z.ziHl10002.mp4?sdtfrom=4330701&guid=l5ezz8nc_551u1jgumk7&vkey=14F065A9982408460E6D1293BD314C181EEF4E361FB1F0D4DDB5D2AEBFA7B08BE9933F7653ADBA834CD9FBE3C0F4B8EAF94209FAC0B6A1940E982475ADB2F4147C47A03D3AF431B2B23034EFA452D30E8AAC963F809D4F281E10D81142A3884A5BD335571C87575385A666193ACBA48CE7CBD095ADFAD247C296B87FA33BBCD1&platform=2
step: 6
val1: 1
val2: 1
fact1: 
fact2: 
fact3: 
fact4: 
fact5: 
```

打开两个不同的视频，观察请求头的数据

![image-20220710170957474](.\asset3\image-20220710170957474.png)

分析哪些是变化的：

- ctime
  - 时间信息，可以模拟

- guid
  - 是变化的，不清楚变化逻辑
- url
  - 这个正常，不同视频url肯定不一致
- vid
  - 这个是url后面的参数，随着不同视频变化，和url绑定，不用管
- val
  - 变化的，还不确定，看同一次请求发送多次会不会变
- pid
  - 不知道变化逻辑
- vurl 
  - 不知道变化逻辑

```
需要分析的有：
guid
vid
val
pid
vurl

可能的情况：
    响应中携带的
        响应头
        响应体
        返回的cookie
        可直接搜值来看是不是响应中返回的
    js算法生成的
```

### cookie

不需要携带cookie

### 请求头

![image-20220710182816135](.\asset3\image-20220710182816135.png)

没有什么特殊值

## 总结

只需要分析请求头中的几个变化的逻辑就可以了。

# 分析变化的值

## guid

```
guid: l5f04zkc_37fq2qnl4fu
```

**简单方式**

先尝试搜索这个值是不是某一个请求返回的：

1. 清除cookie，重新刷新请求
2. 页面刷新出来后进行播放，注意从刷新到这个动作不要清除抓包中抓到的请求，这要从一开始的所有请求中搜索

可以分段搜索，分为`l5f04zkc`和`37fq2qnl4fu`，也可直接整体搜索。

结果没有搜索到

**复杂方式**

没有搜索到，那只能是js算法生成的，只能去抠js的代码。

全局搜索 `guid`关键字

![image-20220710185818484](.\asset3\image-20220710185818484.png)

有这么多结果，不过`cookie: guid..`的这种的不用看，这个是发送请求时cookie的值，所以不用管。只关注js文件中是否有`guid`的结果。

去js文件中找到可疑位置打上断点进行观察。

找到的第一个js文件，有可疑位置，进行断点调试

![image-20220710190529486](.\asset3\image-20220710190529486.png)

调试步骤：

1. 清除cookie
2. 重新刷新网页
3. 点击播放

在刷新时，断点停在了我们打的断点处

![image-20220710190836970](.\asset3\image-20220710190836970.png)

可以看到t的值就是guid的值，我们释放断点，看看是不是我们发送的请求也是这个值

![image-20220710202004205](.\asset3\image-20220710202004205.png)

可以看到，发送请求时是同一个值，接下来就需要探究出t的怎么生成的。

![image-20220710202201633](.\asset3\image-20220710202201633.png)

断点走到if中时，t的值无变化，说明t是画出来的三行代码生成的

![image-20220710202920744](.\asset3\image-20220710202920744.png)

分析代码

```js
function get_guid(){
	let t = ""
    let e = (new Date).getTime().toString(36);  // 时间戳转为36进制的字符串
    let r = Math.random().toString(36).replace(/^0./, "");  // 随机小数转为36为字符串
    t = "".concat(e, "_").concat(r)  // 拼接
    return t
}
```

在js环境中执行结果:

![image-20220710203747698](.\asset3\image-20220710203747698.png)

get_guid搞定

## pid

`pid: l5ezz8xb_sk4e9vh0pzj`

同样的步骤：

1. 清除cookie，重新刷新请求
2. 页面刷新出来后进行播放，注意从刷新到这个动作不要清除抓包中抓到的请求，这要从一开始的所有请求中搜索
3. 搜索pid

有很多pid，文件很多很乱，找了一会儿也没有找到，我们观察和guid的值的结构：

- pid的值和guid的格式看着是 一样的，可以猜测两个是不是用的同一逻辑。

可有如下的猜想：

- 生成pid的代码和guid的代码是同一份代码，而且细心的就会发现生成guid的代码执行了多次
- 生成pid的代码和guid的代码相似，但是不是同一份代码



对于是同一份代码的，清空cookie，打上断点，进行调试，将多个生成的值记录下来，看后面目标请求的pid是否是我们记录的值？

- 结果发现生成guid的代码虽然执行了多次，但是返回的都是同一个值
- 而且这个值是guid的值

所以可能是相似代码，我们从上往下拷贝生成guid的关键代码`(new Date).getTime().toString(36)`进行检索：

![image-20220711205519121](.\asset3\image-20220711205519121.png)

发现只有这几个，我们每个文件打上断点进行记录值，和最后发送的值进行对比，看哪些代码是生成pid的代码

- 第一个文件：打断点验证时一定要清楚cookie刷新
  - 没有执行断点代码

- 第二个文件

  - 没有执行断点代码

- 第三个文件

  - 是guid生成的代码

- 第四个文件

  - 程序停在断点处

  - 和目标请求的参数pid的值一模一样，可以知道此处就是pid生成的代码

  ![image-20220711210346997](.\asset3\image-20220711210346997.png)

和guid的生成代码一样，所以两个生成的逻辑是同一个，不过代码写法不一样。

  

如果每行代码都搜完，打断点也没有找到，只能一个文件一个文件去找了。

  

  

**tips:**

当遇到格式相似的值时，可以先使用户同一份逻辑去试，如果有用，那么就不用看pid的逻辑了，如果没有在走上面的pid的步骤



## vurl

```
vurl: https://mp4playcloud-cdn.ysp.cctv.cn/y000097sc9z.ziHl10002.mp4?sdtfrom=4330701&guid=l5ezz8nc_551u1jgumk7&vkey=14F065A9982408460E6D1293BD314C181EEF4E361FB1F0D4DDB5D2AEBFA7B08BE9933F7653ADBA834CD9FBE3C0F4B8EAF94209FAC0B6A1940E982475ADB2F4147C47A03D3AF431B2B23034EFA452D30E8AAC963F809D4F281E10D81142A3884A5BD335571C87575385A666193ACBA48CE7CBD095ADFAD247C296B87FA33BBCD1&platform=2
```
观察多个相同请求和不同请求时，vurl中各个值的内容，得出以下结论

- `y000097sc9z.ziHl10002.mp4`前半段和视频访问url值一样，后半段值是变化的
- stdfrom 值是固定的
- guid是之前的值
- key 是变化的
- platform是固定的



对这两个变化的值进行分析，

### url中的值

在请求的返回之中找到了这个值，所以任务就拆分成了去模拟这条请求获取返回值中的内容

![image-20220711213738280](.\asset3\image-20220711213738280.png)



#### 分析playvinfo请求

请求的参数

![image-20220711221837203](.\asset3\image-20220711221837203.png)

重新发起请求，该请求的参数

![image-20220711222149962](.\asset3\image-20220711222149962.png)

可以观察到变化的值有

- cKey
- flowid  flowid的格式和guid和pid的格式是相似的，所以去看一眼一次操作的，pid个guid的值，发先flowid的值就是pid的值

![image-20220711222422284](.\asset3\image-20220711222422284.png)

请求的cookie中携带了guid，这个是我们已经解决的值。

请求头没有特殊值。所以这个请求中只需要解决CKey的值逻辑就行了

#### 解决playvinfo请求中的请求参数

cKey的值分析

- 搜索cKey关键字，可疑位置打上断点
- 清除cookie，重新刷新页面发送请求来验证猜想

![image-20220711223529707](.\asset3\image-20220711223529707.png)

经过验证找到一个断点的位置和我们发送请求的值是一样，所以该出断点就是生成cKey的代码，

1.分析`this.getRequestCkey函数`

![image-20220711230311734](.\asset3\image-20220711230311734.png)

`const {guid: t=e.guid, platform: r=e.platform} = this.context;`这段代码的逻辑是从`this.context`中拿到guid赋值给t，拿到platform赋值给r。在另一个控制台测试的代码：

![image-20220711225507793](.\asset3\image-20220711225507793.png)

2.`_.a.getTimeStampStr`函数

![image-20220711230929347](.\asset3\image-20220711230929347.png)

这个函数的作用是返回时间戳，截取时间戳前十位的字符串

3.`Me`函数

![image-20220711231308105](.\asset3\image-20220711231308105.png)

看到这样的代码就难以分析了，但是我们可以在最后一行打个断点看看返回结果是什么

![image-20220711231623681](.\asset3\image-20220711231623681.png)

可以看到几个关键词`iv CBC`，这就能相当是对称加密，再看右面的变量和值，优点类似于ob混淆，将代码替换一下

![image-20220711231910350](.\asset3\image-20220711231910350.png)

可以知道这是一个AES加密的逻辑，接下里就是分析`key iv`这两个值了。

