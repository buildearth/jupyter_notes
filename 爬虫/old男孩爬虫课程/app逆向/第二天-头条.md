# 需求

获取头条的新闻资讯，获取某一个频道的资讯。



# js浏览器环境

我们将浏览器的代码拷贝到本地执行时，可能会用到浏览器的环境

- location
- window
- document
- 等一些环境

浏览器是有这些环境的。

将window放到nodejs中去运行，肯定是报错的，因为默认在nodejs没有浏览器环境。要想不报错，就要在nodejs中补充浏览器环境，补充了环境后，在nodejs执行就跟浏览器的执行一样了。



## 补充浏览器环境

环境准备

- 安装nodejs

- 安装jsdom ，可以来模拟伪造浏览器环境

  ```
  npm install node-gyp@latest sudo npm explore -g npm -- npm i node-gyp@latest
  
  npm install jsdom -g
  ```

补充环境方式一：

```js
const jsdom = require("jsdom");  // 导入jsdom
const {JSDOM} = jsdom;  // 从jsdom对象中导入JSDOM模块

const resourceLoader = new jsdom.ResourceLoader({
    userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36",
});  // 固定写法，

const html = `<!DOCTYPE html><p>Hello world</p>`;

// 核心，实例化dom对象，认为的创造一个浏览器，用dom对象来代指
const dom = new JSDOM(html, {
    url: "https://www.toutiao.com",  // 当前打开的url
    referrer: "https://example.com/",  // referrer
    contentType: "text/html",  // 
    resources: resourceLoader,  // 
});

// 基于dom变量，可以获取浏览器中的一些值
console.log(dom.window.location)
console.log(dom.window.navigator.userAgent)
console.log(dom.window.document.referrer)

// 后续就可以写js代码了
```

![image-20220703200441380](.\asset2\image-20220703200441380.png)

补充环境方式二：

方式一的补环境相当于是简单操作，和真实浏览器环境还是有些差异，在方式一的环境下，编写了一个js函数

```
在js中如果用到了window的操作就得 dom.window这样的方式来编写，在浏览器环境写一段js是直接使用window
window.navigator.userAgent

而我们自己补完的环境前面都有个dom.

```

很显然，第一个方式是不太好的

```js
const jsdom = require("jsdom");
const {JSDOM} = jsdom;

const resourceLoader = new jsdom.ResourceLoader({
    userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36"
});

const html = `<!DOCTYPE html><p>Hello world</p>`;
const dom = new JSDOM(html, {
    url: "https://www.toutiao.com",
    referrer: "https://example.com/",
    contentType: "text/html",
    resources: resourceLoader,
});


//window = {}
window = global;
// 人为补造
const params = {
    location: {
        hash: "",
        host: "www.toutiao.com",
        hostname: "www.toutiao.com",
        href: "https://www.toutiao.com",
        origin: "https://www.toutiao.com",
        pathname: "/",
        port: "",
        protocol: "https:",
        search: "",
    },
    navigator: {
        appCodeName: "Mozilla",
        appName: "Netscape",
        appVersion: "5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36",
        cookieEnabled: true,
        deviceMemory: 8,
        doNotTrack: null,
        hardwareConcurrency: 4,
        language: "zh-CN",
        languages: ["zh-CN", "zh"],
        maxTouchPoints: 0,
        onLine: true,
        platform: "MacIntel",
        product: "Gecko",
        productSub: "20030107",
        userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36",
        vendor: "Google Inc.",
        vendorSub: "",
        webdriver: false
    }
};

Object.assign(global,params);


//在下面如果你使用
location.href
navigator.appCodeName
window.location.href
```

# 头条

网址：`https://www.toutiao.com/`

找到返回数据的请求:

![image-20220703205826296](.\asset2\image-20220703205826296.png)

其参数有：

```
channel_id: 3189398999  频道，科技是一个值，娱乐是一个值
min_behot_time: 0  获取第一页，第二页...
refresh_count: 1
category: pc_profile_channel
client_extra_params: {"short_video_item":"filter"}
aid: 24
app_name: toutiao_web
_signature: _02B4Z6wo00101ufq3DAAAIDDhOAcWKM.cqrnztiAANtIv7eCc9U74h26St6hSE6nFgoD.Y.ptpPbBAjh2HNglCM49cXsDtVEU7B0NgUkNSnpVAgeLm2eg5qlCsGTc9tgJ.DTm-ITmV2TS23A7e   有时效性，只能用一段时间
```

看到`sign`或者`signature`等类似的关键字，一定要敏感性，这个就是加密之后的凭证，你给后端发消息携带着这个凭证，后端才会给你正确结果，如果携带的凭证过期，或者无效就拿不到正确的结果。

如果一直拿着同一个凭证，去请求，可能只能在几分钟内，可以拿到数据，过了这个时间就拿不到数据了。



这个请求中，最重要的就是破解这个凭证的生成。



## 初步分析

用requests模块初步模拟请求，看请求头，请求头，cookie中哪些是必须的，哪些是可以不携带的

1. 请求头中设定UA，如果不行，再挨个尝试其他请求头
2. 请求体中，全部和浏览器保持一致
3. 可以看不携带cookie是否能拿到数据，如果可以就不用携带cookie

第一步的尝试：

```python
import requests

headers = {
    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36"
}

# url是直接从浏览器中复制的
url = 'https://www.toutiao.com/api/pc/list/feed?channel_id=3189398972&min_behot_time=0&refresh_count=1&category=pc_profile_channel&client_extra_params=%7B%22short_video_item%22:%22filter%22%7D&aid=24&app_name=toutiao_web&_signature=_02B4Z6wo00901KhRlHwAAIDBy1tUFRdNg.iodZDAAEjbksUY5wJ4HkAuODMq99.05DdQaCDq31GYUNja5N8JV5DSbdW2f5UwPNQirj8YB3.CJUBGeGzbuhgIbeXwXQx8sg7DzMhKSng96qe462'
resp = requests.get(url, headers=headers)
print(resp.text)
```

![image-20220704204737916](.\asset2\image-20220704204737916.png)

可以直接拿到数据，所以我们只需要一个请求头数据和请求体就能拿到想要的数据了，接下来去看请求体中的参数

![image-20220704204912121](.\asset2\image-20220704204912121.png)

上面分析过，各个请求体参数的意义，所以只需要解开`_signature`的值即可

## _signature

使用全局搜索的方式来找，找到可疑位置打上断点验证猜想

![image-20220704205711781](.\asset2\image-20220704205711781.png)

看到`interceptors.request.use`就可以知道这是`axios`拦截器，所有的请求都会经过这里，并在这里给加上`_signature`请求参数。

下来只需要分析`var n = x(V.getUrl(e), e)`这代码即可

![image-20220704210023701](.\asset2\image-20220704210023701.png)

```
V.getUrl(e)  返回的是请求的url携带除了_signature以外的所有参数
e 是请求数据相关的一个对象
```

x函数的实现：

```js
function x(e, t) {
    var n, r, a = "".concat(location.protocol, "//").concat(location.host);
    (function(e) {
        return !A.some((function(t) {
            return e.indexOf(t) > -1
        }
        ))
    }
    )(e) && (a += "/toutiao");
    var o = {
        url: a + e
    };
    t.data && (o.body = t.data)
    return (null === (n = window.byted_acrawler) || void 0 === n || null === (r = n.sign) || void 0 === r ? void 0 : r.call(n, o)) || ""
}
```

用到了几个浏览器环境

```
location.protocol  -> 'https:'
location.host  -> 'www.toutiao.com'
window.byted_acrawler  -> 这是一个对象
```

分析代码

```js
A = ["/api/pc/list/feed", "/search/suggest/hot_words", "/hot-event/hot-board/", "/stream/widget/local_weather/", "search/suggest/hot_words/", "/api/pc/list/user/feed", "/2/article/v88/refresh_tip/", "/api/pc/user/follow", "/video/app/pseries/", "/ugc/video/v1/pseries", "/ugc/video/v1/player_info", "/action/api/v1/do_action/", "/api/amos_items/"]

function x(e, t) {
    var n, r, a = 'https://www.toutiao.com'
    (function(e) {  // 如果e请求url中包含允许的请求，则在a不变
        return !A.some((function(t) {
            return e.indexOf(t) > -1
        }
        ))
    }
    )(e) && (a += "/toutiao");
    // 执行完 a的值是'https://www.toutiao.com'
    var o = {
        url: a + e
    };
    // o的值是{url: 'https://www.toutiao.com/api/pc/list/feed?channel_i…em%22:%22filter%22%7D&aid=24&app_name=toutiao_web'}
    t.data && (o.body = t.data)  // t.data没有值
    return (null === (n = window.byted_acrawler) || void 0 === n || null === (r = n.sign) || void 0 === r ? void 0 : r.call(n, o)) || ""
    
    // 分析最后一行代码
    // (null === (n = window.byted_acrawler)
    n = window.byted_acrawler
    null === n 
    // n肯定是不为null的，所以第一个为false
    
    // void 0 === n
    // viod 0 是undefine
    // 这个也是false
    
    // null === (r = n.sign)
    r = n.sign
    null === r
    // n.sign是一个函数，是false
    
    // void 0 === r
    // r是一个函数，是false
    
    // 所以(null === (n = window.byted_acrawler) || void 0 === n || null === (r = n.sign) || void 0 === r  这个表达式的值是false，执行后面的代码
    
    // 最后一行代码简化下来就是
    n = window.byted_acrawler
    r = n.sign
    return r.call(n, o)
}
```

简化代码

```js
function x(e, t) {
    var n, r, a = 'https://www.toutiao.com'
    // 执行完 a的值是'https://www.toutiao.com'
    var o = {
        url: a + e
    };
    t.data && (o.body = t.data)  // t.data没有值
    return window.byted_acrawler.sign.call(window.byted_acrawler, o)
}
```

分析`window.byted_acrawler.sign`函数，这个函数我们看了之后用分析不好分析，直接采用execjs的方式将其代码执行，不关心内部逻辑

![image-20220704215439359](.\asset2\image-20220704215439359.png)

用了很多不知道的变量 `e K b ...`所以拷贝的时候，要从该函数的闭包去拷贝该闭包内的所有内容。

当我们找这个函数中其他变量的依赖关系时：

- 可能是在闭包中，将闭包整个拷贝
- 可能整个文件是个大闭包函数，将整个文件拷贝
- 可能在其他文件中，再去其他文件中找依赖

这里是将整个文件全部拷贝，拷贝之后编写一个html文件，引入我们拷贝下来的js，在浏览器中打开我们写的html，相当于通过我们自己的浏览器去调用执行一下我们拷贝的js

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="./sdk1.js"></script>
</head>
<body>

</body>
</html>
```

在浏览中打开后，console中没有报错，就是好现象，说明从网页上拷贝过来的js是独立的可以加载直接使用的js。

可以看到我们自己拷贝的js是可以执行，并生成数据的

![image-20220704221127746](.\asset2\image-20220704221127746.png)

在浏览器中可以成功的运行，我们就可以在python中通过jsdom补环境来执行这个代码。

# 环境的补充并执行

补充环境代码，固定写法

```js
const jsdom = require("jsdom");
const {JSDOM} = jsdom;

const resourceLoader = new jsdom.ResourceLoader({
    userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.55 Safari/537.36"
});

const html = `<!DOCTYPE html><p>Hello world</p>`;
const dom = new JSDOM(html, {
    url: "https://www.toutiao.com",
    referrer: "https://example.com/",
    contentType: "text/html",
    resources: resourceLoader,
});


//window = {}
window = global;
// 人为补造
const params = {
    location: {
        hash: "",
        host: "www.toutiao.com",
        hostname: "www.toutiao.com",
        href: "https://www.toutiao.com",
        origin: "https://www.toutiao.com",
        pathname: "/",
        port: "",
        protocol: "https:",
        search: "",
    },
    navigator: {
        appCodeName: "Mozilla",
        appName: "Netscape",
        appVersion: "5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36",
        cookieEnabled: true,
        deviceMemory: 8,
        doNotTrack: null,
        hardwareConcurrency: 4,
        language: "zh-CN",
        languages: ["zh-CN", "zh"],
        maxTouchPoints: 0,
        onLine: true,
        platform: "MacIntel",
        product: "Gecko",
        productSub: "20030107",
        userAgent: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/93.0.4577.82 Safari/537.36",
        vendor: "Google Inc.",
        vendorSub: "",
        webdriver: false
    }
};

Object.assign(global,params);


//在下面如果你使用

console.log(location.href)
console.log(navigator.appCodeName)
console.log(window.location.href)
console.log(window.appCodeName)

// 上面的不够，继续补，缺什么补什么环境
// 拷贝页面的代码

```

![image-20220704222258989](.\asset2\image-20220704222258989.png)

可以将判断条件简单分析，也可以直接在console中输出查看结果

![image-20220704222421820](.\asset2\image-20220704222421820.png)

就是window对象，可以将代码简写

![image-20220704222510516](.\asset2\image-20220704222510516.png)

在python的terminal中执行`node sdk1.js`，发现报错了

![image-20220704222114983](.\asset2\image-20220704222114983.png)

翻译报错，从undefined的中无法读取到referrer,refferer是请求头中的一个key，一般获取的方式`document.referrer`,所以环境变量中可能少了referrer，将其加入

```
document = dom.window.document
```

再次执行`node sdk1.js`，又报错了

![image-20220704223653158](.\asset2\image-20220704223653158.png)

这个时候去看执行window._$jsvmprt的参数，参数中出现了浏览器环境，可能会导致结果和我们本地执行的不一致，在函数中打上断点看传递进去的是什么值

![image-20220704224500248](.\asset2\image-20220704224500248.png)

第二个参数是个列表，和结果保持一致

```js
第二个参数对应修改
[,,,,, "undefined" != typeof Object ? Object : void 0, void 0, "undefined" != typeof TypeError ? TypeError : void 0, "undefined" != typeof document ? document : void 0, "undefined" != typeof InstallTrigger ? InstallTrigger : void 0, "undefined" != typeof safari ? safari : void 0, "undefined" != typeof Date ? Date : void 0, "undefined" != typeof Math ? Math : void 0, "undefined" != typeof navigator ? navigator : void 0, "undefined" != typeof location ? location : void 0, "undefined" != typeof history ? history : void 0, "undefined" != typeof Image ? Image : void 0, "undefined" != typeof console ? console : void 0, "undefined" != typeof PluginArray ? PluginArray : void 0, "undefined" != typeof indexedDB ? indexedDB : void 0, "undefined" != typeof DOMException ? DOMException : void 0, "undefined" != typeof parseInt ? parseInt : void 0, "undefined" != typeof String ? String : void 0, "undefined" != typeof Array ? Array : void 0, "undefined" != typeof Error ? Error : void 0, "undefined" != typeof JSON ? JSON : void 0, "undefined" != typeof Promise ? Promise : void 0, "undefined" != typeof WebSocket ? WebSocket : void 0, "undefined" != typeof eval ? eval : void 0, "undefined" != typeof setTimeout ? setTimeout : void 0, "undefined" != typeof encodeURIComponent ? encodeURIComponent : void 0, "undefined" != typeof encodeURI ? encodeURI : void 0, "undefined" != typeof Request ? Request : void 0, "undefined" != typeof Headers ? Headers : void 0, "undefined" != typeof decodeURIComponent ? decodeURIComponent : void 0, "undefined" != typeof RegExp ? RegExp : void 0]
```



最终修改的结果

![image-20220704225026455](.\asset2\image-20220704225026455.png)

执行的结果：

![image-20220704225058366](.\asset2\image-20220704225058366.png)

最后的结果出来了，但是还有报错，是因为还依赖了`canvas`这个包，
