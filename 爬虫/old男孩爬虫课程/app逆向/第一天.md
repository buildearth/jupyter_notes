

课件地址：https://pan.baidu.com/s/1tynHeCDN9w5ehvlVV6ogxA

提取码: 36k2

# 手机

推荐使用小米手机

本机资料路经`F:\红米8a_root\TWRP-3.4.2B-0111-REDMI8A-CN-wzsx150-fastboot`

刷面具教程：https://www.bilibili.com/video/BV1Ly4y1u7YE/?spm_id_from=333.788.recommend_more_video.-1&vd_source=034d40dbd70722fa67fc0433747ea6b4

下载rec:后缀是fastboot的，有一键刷入工具

![image-20220706202241329](.\asset\image-20220706202241329.png)

在手机和电脑用数据线连接的状态下，关机，按住电源键和音量下键进入，然后点击电脑上的一键刷入，按照提示进行操作

![image-20220706202437421](.\asset\image-20220706202437421.png)

# 目标

今天的案例是给b站的视频刷播放量。

# 分析和定位到网路请求

这个过程的难点就是定位到哪个请求是增长播放量的。

## 浏览器抓包顺序

可能由于其他排序导致浏览器抓到的包顺序不是按照请求的顺序，可按照下面设置进行解决

![image-20220704203233238](.\asset\image-20220704203233238.png)

## 目的

- 分析，是分析需求，需求是要给网站的视频增加播放量，我们手动增加播放量的场景是打开网站，点击视频播放，这样网站的播放量就会增加1.

- 定位网络请求是，需要对发送的请求进行分析，找到影响视频播放量的请求。

## 分析过程

在分析时，最好使用无痕窗口来进行分析，这个时候是一个纯净的浏览器环境。如果使用普通的浏览器窗口，可能会由于我们之前浏览过b站，或者登陆过b站，对我们分析时请求头或者cookie信息会产生污染，不易于分析。



当打开这个b站的某一个视频页面时(我选择的视频链接`https://www.bilibili.com/video/BV1xN4y1g7XS`)，视频自动播放了，此时有太多的网络请求在，我们需要检索的请求太多了。

![image-20220701214853527](.\asset\image-20220701214853527.png)

我们可以进行猜测，要增加播放量，可能是点击了播放按钮，播放量才会增加，所以我们需要设置打开网站时不自动播放视频，设置打开视频网站不自动播放需要登录b站账号后才可以。

![image-20220701215320043](.\asset\image-20220701215320043.png)

登陆并且设置了不自动播放后，刷新网站后，先将请求清空，在点击播放按钮，进行抓包

![image-20220701215859535](.\asset\image-20220701215859535.png)

如上图，我们点击播放时拿到了上述的几个请求，请求少了很多很多，我们只需要每一个请求进行分析，看哪个请求会影响到播放量，这个请求就是要找的请求。

## 定位请求

在分析每个请求时，这个过程和普通的抓取评论信息不一致，评论信息可以从网络请求的响应结果中知道哪个请求是我们要找的请求，但是这个不一样，这个不知道哪个请求会影响到播放量，所以在找具体是哪个请求时，我们每个请求都要去尝试多发几次(发100-200次)，看是不是这个请求影响的播放量，直到最后找到那个请求。

从上往下，对每个请求依次进行模拟，每个请求发送100-200次，在看播放量是否会被这个请求影响，如果不是，继续下一个请求，直到找到影响播放量的请求。

也可以不用从上往下每个请求都试，可以先排除get请求，因为播放量肯定是用户播放了这个视频，要将用户点击视频的这个操作传递到后端，才能获取对应视频资源数据，进行播放，所以这个请求有很大可能是一个**post** 请求，所以先挨个分析post请求，如果没有找到影响播放量的请求，再去分析get请求。

最终分析下来，下面请求影响了播放量`https://api.bilibili.com/x/click-interface/click/web/h5`

![image-20220701220846080](.\asset\image-20220701220846080.png)



## 定位到请求后

找到这个请求后，去测试请求头中的内容和cookie内容，哪些必须带上，哪些可以不带，能拿到数据，对于不带的可以忽略。

进行任务拆解，根据请求体，请求头，cookie中的内容进行拆解。



找到目标请求后，我们需要对这个请求进行分析，最关键的部分是：

- 请求体
- 请求头
- cookie

可以先使用浏览器侧的请求体，请求头，cookie来进行尝试请求，看是不是能成功请求，可以用来检测哪些信息是可以不携带也能成功请求的，对于这些信息我们可以进行忽略，进行这个操作时，最好加个代理ip，多次请求可能会将你自己的ip封掉。

如果不进行浏览器数据模拟访问，我们可以直接分析，先看请求体，再看请求头，再看cookie。发多次请求，看哪些数据是变化的，哪些数据是不变的，对于不变的我们就可以使用固定值，对于变化的我们需要去模拟其变化。在观察多次请求时，务必要打开新的无痕浏览器窗口，或者点击浏览器的小锁对cookie进去清除后再分析

清除浏览器的cookie

- 点击左上角的小锁，右键点击

![image-20220701222133644](.\asset\image-20220701222133644.png)

- 右键点击cookie，对所有的cookie进行移除

​	![image-20220701222313436](.\asset\image-20220701222313436.png)

# 请求的具体分析

## 请求体

可以多切换几个视频，多抓一下包，看看请求体中哪些是变化的，哪些不是变化的。

- 如果不变化的，让其值固定就好了
- 变化的，就去分析其值的生成方式

在分析一下请求体中键值对的名字有没有一些特点：

![image-20220701223724621](.\asset\image-20220701223724621.png)

变化的值如下：

- aid
  - 需要去分析生成值的逻辑
- cid
  - 需要分析生成值的逻辑
- bvid
  - 这个值在访问的url中有，其实指的就是当前这个视频，`https://www.bilibili.com/video/BV1qx411K7fm/?vd_source=fd1a087270585f2eb4974cc97df8486c`
- ftime
  - 这个根据名字就可以知道是和时间相关，其值也是时间戳的值，所以这个值的生成逻辑我们清楚了，这个值其实就是打开这个视频网页的时间
- stime
  - 这个也是和时间相关的值，表示的是播放视频的事件
- from_spmid
  - 这个值意义不明确，但是都是播放视频，有些请求中没有也可以，在尝试不携带值访问之后，可以成功发送请求，所以这个值可以不管
- refer_url
  - 这个表示是从哪个视频点击来的这个视频，如果是直接在网页中输入这个视频网址`https://www.bilibili.com/video/BV1qx411K7fm`,那么就不会有值，所以这个也不用管
- spmid
  - 和from_spmid一样。

分析完，在请求体中我们要搞的就是aid和cid这两个值的生成方式。

aid和cid这两个值的分析：

- 可能是这个请求之前，某个请求返回来的数据中有aid和cid这两个值，返回的数据可能是json或者字符串或者页面源代码
  - 就可以模拟请求，将这两个数据拿过来即可
- 可能是这个请求之前的其他请求的响应，放到cookie中了，或者是放在了响应头中返回了
  - cookie
  - header
  - body
- 前两个方式都没有，没有任何请求返回了这两个数据，他可能是通过js代码经过了某种加密之后的数据

分析这个值时，就需要按照上面的顺序进行逐一的排除，可以一个一个请求去看，也可以搜索aid,cid这两个关键字，也可以直接搜这两个值。如果搜索到了这个值，那么就是某一个请求把这个数据返回回来了。

搜索的方式是：

![image-20220701225418368](.\asset\image-20220701225418368.png)

进行搜索aid的值：

![image-20220701230044589](.\asset\image-20220701230044589.png)

在这个请求中找到了值，再这个响应中在搜索cid的值也是存在在，所以我们模拟这个请求，将响应结果拿到，在拿出aid和cid的值即可，这个请求是`https://www.bilibili.com/video/BV1qx411K7fm`

![image-20220701230249491](.\asset\image-20220701230249491.png)

分析这个请求拿到的数据，cid和aid的数据放在了页面源代码中的js代码部分，可以通过re来获取

- 方式一，cid和aid是存放在对象中的，可以使用re将整个对象获取到，通过pyhton的json将其转换为字典类型，然后直接拿到值

```python
import requests
import re
import json
headers = {
    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36",
}
url = 'https://www.bilibili.com/video/BV1xN4y1g7XS'
resp = requests.get(url=url, headers=headers)
# ["",]
data_list = re.findall(r'__INITIAL_STATE__=(.+);\(function', resp.text)
data_dict = json.loads(data_list[0])

aid = data_dict['aid']
cid = data_dict['videoData']['cid']

print(aid)
print(cid)
```

## 请求cookie

 当前请求携带了一些cookie，cookie的值可能有以下几种可能(要在当前请求之前的请求中查看)：

- 固定值

- 是哪个请求返回的cookie
  - 响应的cookie
  - 响应的body中的数据，进行操作后，变为cookie
  - 在响应的header中
- js算法生成的

cookie有这么多，就得在这个之前的请求中查看

![image-20220702220201770](.\asset\image-20220702220201770.png)

### buvid3

从第一个请求开始找，看哪个请求的响应返回了cookie

buvid3，这个请求的响应返回了cookie

![image-20220702215842201](.\asset\image-20220702215842201.png)

我们可以使用`resp.cookies.get_dict()`拿到响应返回的cookie

```python
import requests
import re
import json
headers = {
    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36",
}
url = 'https://www.bilibili.com/video/BV1xN4y1g7XS'
resp = requests.get(url=url, headers=headers)
print(resp.cookies.get_dict())  # -> {'buvid3': '902267FD-3E0E-EE74-DD16-149537B6837856549infoc'}
```

### b_lsid

从上一直往下翻找，看是否有response cookie，一直没有，直到找到了一个请求，他有Request Cookies，他发送请求的时候携带了cookie，这个cookie也是我们想要的cookie，所以要分析这个cookie的生成
![image-20220702221022489](.\asset\image-20220702221022489.png)

这就意味着，在第一请求`BV1xN4y1g7XS`和`spi`这个请求之间生成了三个cookie，但是这两个请求之间的请求中没有response cookie有这三个cookie的值，在响应体中也没有这三个cookie的值，那么就剩下了两种可能

- 固定值
- js代码动态生成的

经过分析：

- buvid3之前已经拿到了
- CURRENT_BLACKGAP  这个值不变，多发几次请求来验证
- CURRENT_FNVAL 这个值不变
- b_lsid 值需要确认生成逻辑，多发几次请求，每次都变化
- _uuid 值需要确认生成逻辑

需要分析b_lsid的值生成逻辑，可以有多重方式

- 请求调用栈
- 在所有代码中搜索cookie的key关键字

这里采用搜索关键字的方式，前端要设置一个cookie，其代码有很大可能是和下面一样

```js
setcookie("b_ksid", xxxx)  // 第一个参数是cookie的key，第二个参数是cookie的值
```

代码分析流程：

1.找到`b_lsid`设置的可疑代码位置

![image-20220702232814460](.\asset\image-20220702232814460.png)

2.点击浏览器网址栏最左侧的小锁，将所有的cookie清除

![image-20220702233122274](.\asset\image-20220702233122274.png)



```js
Object(f.b)(e)  // 相当于执行了f.b这个函数，其参数是e
```

找到代码位置，打上断点，将cookie在小锁处清楚一下，再模拟的时候就相当于一个新设备来，这个时候cookie就会重新生成，因为有些平台的cookie生成之后就不会重新生成了，可能就不会走我们打的断点，我们必须清除cookie，构造一个新的环境。

每一步的js代码可以分析，备注

python的16进制会带一个前置0x,直接那后面的就行

3.重新发起请求，程序停在打的断点处

![image-20220702233243591](.\asset\image-20220702233243591.png)

4.结合断点和console对这里的代码进行分析

```js
// 原js代码
var e = this.splitDate()
, t = Object(f.b)(e.millisecond)
, t = "".concat(Object(f.c)(8), "_").concat(t);
this.lsid = t,
this.time.start = e.millisecond,
this.time.day = e.day,
c.a.setCookie("b_lsid", t, 0, "current-domain")
```

按行对js代码进行分析：

- `var e = this.splitDate()`

```js
// e = this.splitDate()

// this.splitDate()函数的定义
{
    key: "splitDate",
    value: function(e) {  // 函数定义
        var t = new Date(e || Date.now())  // 调用是没有进行参，是undefine，所以 t = new Date(Date.now())  是当前的时间对象
        , n = t.getDate()  // 获取当前月的当天的日期
        , r = t.getHours() // 获取当前的小时
        , e = t.getMinutes()  // 获取当前的分钟
        , t = t.getTime();  // 获取当前的时间戳
        return {
            day: n,
            hour: r,
            minute: e,
            second: Math.floor(t / 1e3),  // Math.floor是向下取整
            millisecond: t
        }  // 返回的是一个对象，对象里放的是时间相关
    }
}
```

- `t = Object(f.b)(e.millisecond)`

```js
// t = Object(f.b)(e.millisecond)

// Object(f.b)(xxx)  相对于执行f.b函数，参数是xxx，等价于f.b(xxx)

// 需要去看f.b的实现，参数是e.millisecond，是当前的时间戳

o = function(e) {
    // Math.ceil是向上取整，toString(16)是转为16进制的字符串，toUpperCase是字符串字符大写
    return Math.ceil(e).toString(16).toUpperCase()
}

```

这行代码的功能是，将时间戳的值向上取整，然后再转为16进制的字符串，再大写。需要注意的是js中将整形转为16进制字符串直接是对应字母组成的字符串

```js
e.millisecond.toString(16) // -> '181bf97ae69'
```

在python中，将整形转为16进制，会带前缀，需要将这个前缀处理掉

```python
a = 1656776797801
hex(a)  # -> '0x181bf97ae69'
# 处理掉0x前缀，并大写
hex(a).upper()[2:]  # -> '181BF97AE69'
```

用python实现这个函数：

```python
import math
def o(data):
	return hex(math.ceil(data))[2:].upper()
```

- `t = "".concat(Object(f.c)(8), "_").concat(t);`

```js
// t = "".concat(Object(f.c)(8), "_").concat(t);

//这行代码中调用了f.c函数，其参数是8
// f.c函数的定义
a = function(e) {  // e的值是8
    for (var t = "", n = 0; n < e; n++)  // 循环e次，也就是八次
        t += o(16 * Math.random());  // 这里调用了o函数，参数是0-16的随机小数
    return s(t, e)  // 调用了s这个函数，第一个参数是8个随机数组成的字符串，第二个参数是8
}

// o函数的定义，似曾相识，我们之前用python实现了
o = function(e) {
    return Math.ceil(e).toString(16).toUpperCase()
}

// s函数的定义，
s = function(e, t) {  // e是随机数拼接的字符串，t是8
    var n = "";
    if (e.length < t)  // 如果字符串的长度小于8，则在左侧补'0'凑够8位
        for (var r = 0; r < t - e.length; r++)
            n += "0";
    return n + e
}

// concat是拼接字符串
```

用python来实现

```python
def o(data):
	return hex(math.ceil(data))[2:].upper()

def s(data, lenth):
	return data.rjust(lenth, '0')   # 字符串不够指定长度在左侧补'0'

def a(data):
    res = ""
    for i in range(data):
        res += o(16*random.random())
    return s(res, data)

t = o(int(time.time()*1000))
t = "" + a(8) + "_" + t  # t = 1656776797801
print(t)  # -> 5F10B4BD_181C1FF37AA
```

最后的t的值就是cookie中的b_lsid的值，找到逻辑并用python代码实现了。

### _uuid

和`b_lsid`，肯定有地方是设置了`_uuid`的值，我们安装相同的方式去找代码。

`this._uuid = Object(f.a)()`这个函数就是`_uuid`的生成

![image-20220703112311529](.\asset\image-20220703112311529.png)

打上断点进行调试，进行猜测验证，看是不是找到的位置，断点后依旧是清除cookie，然后在刷新页面，模拟第一次发请求。

找到`f.a`函数的代码

```js
var r = function() {
    var e = a(8)
    , t = a(4)
    , n = a(4)
    , r = a(4)
    , o = a(12)
    , i = (new Date).getTime();
    return e + "-" + t + "-" + n + "-" + r + "-" + o + s((i % 1e5).toString(), 5) + "infoc" // 这个就是将随机生成的字符串用'-'拼接
}
, a = function(e) {  // 已经用python实现了
    for (var t = "", n = 0; n < e; n++)
        t += o(16 * Math.random());
    return s(t, e)
}
, s = function(e, t) {  // 已经用python实现了
    var n = "";
    if (e.length < t)
        for (var r = 0; r < t - e.length; r++)
            n += "0";
    return n + e
}
, o = function(e) {  // 已经用python实现了
    return Math.ceil(e).toString(16).toUpperCase()
}
```

`'12345678-1234-1234-1234-123456789abc'`看到这种格式的字符串`8-4-4-4-12`，其实就是uuid，直接使用python代码可以直接生成

```python
import uuid
uuid.uuid4()  # -> UUID('126ff50c-65cb-4ada-a017-435687a0d649')
```

原js代码中只有第一个函数没有用python实现，

```python
def get_uuid():
    e = a(8)
    t = a(4)
    n = a(4)
    r = a(4)
    o = a(12)
    i = time.time()*1000
    return e + "-" + t + "-" + n + "-" + r + "-" + o + s(str(int(i % 100000)), 5) + "infoc" 
m_uuid = get_uuid()
print(m_uuid)  # -> CC6B107CD-8B16-56EB-9C15-6454A9D312D537192infoc
```



### buvid4

`spi`请求返回值中有b_4这一项，和我们`h5`请求中的`buvid4`值是一样的

![image-20220703120607119](.\asset\image-20220703120607119.png)

`h5`请求的cookie

![image-20220703120803617](.\asset\image-20220703120803617.png)

所以要发送这个请求拿到返回值中的`b_4`

```python
import requests
import re
import json
import math
import random
import time

headers = {
    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36",
}
session = requests.session()
session.headers = headers
url = 'https://www.bilibili.com/video/BV1xN4y1g7XS'
resp = session.get(url=url)
# ["",]
data_list = re.findall(r'__INITIAL_STATE__=(.+);\(function', resp.text)
data_dict = json.loads(data_list[0])

aid = data_dict['aid']
cid = data_dict['videoData']['cid']

print(aid)
print(cid)
print(resp.cookies.get_dict())
# buvid3
buvid3 = resp.cookies.get_dict().get('buvid3')

# b_lsid
def o(data):
	return hex(math.ceil(data))[2:].upper()

def s(data, lenth):
	return data.rjust(lenth, '0')   # 字符串不够指定长度在左侧补'0'

def a(data):
    res = ""
    for i in range(data):
        res += o(16*random.random())
    return s(res, data)

t = o(int(time.time()*1000))
b_lsid = "" + a(8) + "_" + t  # t = 1656776797801
print(b_lsid)  # -> 5F10B4BD_181C1FF37AA


# uuid
def get_uuid():
    e = a(8)
    t = a(4)
    n = a(4)
    r = a(4)
    o = a(12)
    i = time.time()*1000
    return e + "-" + t + "-" + n + "-" + r + "-" + o + s(str(int(i % 100000)), 5) + "infoc"
m_uuid = get_uuid()
print(m_uuid)

url = 'https://api.bilibili.com/x/frontend/finger/spi'
session.cookies.set('CURRENT_BLACKGAP', "1")
session.cookies.set('CURRENT_FNVAL', "4048")
session.cookies.set('b_lsid', b_lsid)
session.cookies.set('_uuid', m_uuid)
resp = session.get(url)
print(resp.text)  # -> {"code":0,"data":{"b_3":"647696C9-6CB2-AD00-9678-8EB4961732A665797infoc","b_4":"E1A41DD1-C3E8-39BE-A648-A1068F5E56C165797-022070312-5IRAhaByl1BvUJUUkQOIAKurZ392fM5QiJ1Q9U1Op71ZLQCKvtqo1Q=="},"message":"ok"}
b_4 = resp.json()['data']['b_4']
print(b_4)
```

### b_timer

从spi下个请求开始继续找下面的请求

这个不会影响播放量的刷新，可以不携带

### sid

v2这个请求的响应返回了sid的cookie值

![image-20220703122931014](.\asset\image-20220703122931014.png)

请求的cookie和参数：

![image-20220703123350732](.\asset\image-20220703123350732.png)

我们只需要模拟这个请求发送即可

```python
url = 'https://api.bilibili.com/x/player/v2'
params = {
    "cid": cid,
    "aid": aid,
    "bvid": bvid,
}
session.cookie.set('CURRENT_BLACKGAP', "0")
resp = session.get(url, params=params)
print(resp.cookies.get_dict())  # {'sid': '6ko1y559'}
```

cookie的值全部分析结束。

# 最终实现代码，刷新播放量

就是模拟h5这个请求，这个代码完成后，刷到一定数量后就不张了，或者涨的很慢，因为做了IP限制，或者触发了风控机制了。

接下来应该挂上代理ip来跑，伪造的就是好多人同时在访问这个视频。

模拟h5请求

```python
import requests
import re
import json
import math
import random
import time
from urllib.parse import quote

headers = {
    "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/103.0.0.0 Safari/537.36",
}
session = requests.session()
session.headers = headers
url = 'https://www.bilibili.com/video/BV1xN4y1g7XS'
bvid = url.split('/')[-1]
resp = session.get(url=url)
# ["",]
data_list = re.findall(r'__INITIAL_STATE__=(.+);\(function', resp.text)
data_dict = json.loads(data_list[0])

aid = data_dict['aid']
cid = data_dict['videoData']['cid']

print(aid)
print(cid)
print(resp.cookies.get_dict())
# buvid3
buvid3 = resp.cookies.get_dict().get('buvid3')

# b_lsid
def o(data):
	return hex(math.ceil(data))[2:].upper()

def s(data, lenth):
	return data.rjust(lenth, '0')   # 字符串不够指定长度在左侧补'0'

def a(data):
    res = ""
    for i in range(data):
        res += o(16*random.uniform(0, 1))
    print('res', res)
    return s(res, data)

t = o(int(time.time()*1000))
b_lsid = "" + a(8) + "_" + t  # t = 1656776797801
print(b_lsid)  # -> 5F10B4BD_181C1FF37AA

# uuid
def get_uuid():
    e = a(8)
    t = a(4)
    n = a(4)
    r = a(4)
    o = a(12)
    i = time.time()*1000
    return e + "-" + t + "-" + n + "-" + r + "-" + o + s(str(int(i % 100000)), 5) + "infoc"
m_uuid = get_uuid()
print(m_uuid)

url = 'https://api.bilibili.com/x/frontend/finger/spi'
session.cookies.set('CURRENT_BLACKGAP', "1")
session.cookies.set('CURRENT_FNVAL', "4048")
session.cookies.set('b_lsid', b_lsid)
session.cookies.set('_uuid', m_uuid)
resp = session.get(url)
print(resp.text)  # -> {"code":0,"data":{"b_3":"647696C9-6CB2-AD00-9678-8EB4961732A665797infoc","b_4":"E1A41DD1-C3E8-39BE-A648-A1068F5E56C165797-022070312-5IRAhaByl1BvUJUUkQOIAKurZ392fM5QiJ1Q9U1Op71ZLQCKvtqo1Q=="},"message":"ok"}
b_4 = resp.json()['data']['b_4']
print(b_4)
session.cookies.set('buvid4', quote(b_4))

# sid
url = 'https://api.bilibili.com/x/player/v2'
params = {
    "cid": cid,
    "aid": aid,
    "bvid": bvid,
}
resp = session.get(url, params=params)
print(resp.cookies.get_dict())  # {'sid': '6ko1y559'}

h5_url = 'https://api.bilibili.com/x/click-interface/click/web/h5'
session.cookies.set('CURRENT_BLACKGAP', '0')
session.cookies.set('blackside_state', '0')
ctime = int(time.time())
data = {
    "aid": aid,
    "cid": cid,
    "bvid": bvid,
    "part": "1",
    "mid": "0",
    "lv": "0",
    "ftime": ctime - random.randint(100, 500),  # 浏览器首次打开时间
    "stime": ctime,
    "jsonp": "jsonp",
    "type": "3",
    "sub_type": "0",
    "from_spmid": "",
    "auto_continued_play": "0",
    "refer_url": "",
    "bsource": "",
    "spmid": ""
}

resp = session.post(url=h5_url, data=data)
print(session.cookies.get_dict())
print(data)
print(resp.status_code)

```

结合proxies的代码

```python
import time
import math
import random
import time
import uuid
import requests
import re
import json


def get_tunnel_proxies():
    proxy_host = "tunnel2.qg.net:17955"
    proxy_username = "xxxxxxx"
    proxy_pwd = "xxxxxxxxxxx"

    return {
        "http": "http://{}:{}@{}".format(proxy_username, proxy_pwd, proxy_host),
        "https": "http://{}:{}@{}".format(proxy_username, proxy_pwd, proxy_host),
    }


def gen_uuid():
    uuid_sec = str(uuid.uuid4())
    time_sec = str(int(time.time() * 1000 % 1e5))
    time_sec = time_sec.rjust(5, "0")

    return "{}{}infoc".format(uuid_sec, time_sec)


def gen_b_lsid():
    data = ""
    for i in range(8):
        v1 = math.ceil(16 * random.uniform(0, 1))
        v2 = hex(v1)[2:].upper()
        data += v2
    result = data.rjust(8, "0")

    e = int(time.time() * 1000)
    t = hex(e)[2:].upper()

    b_lsid = "{}_{}".format(result, t)
    return b_lsid


def play(video_url, proxies):
    bvid = video_url.rsplit("/")[-1]
    session = requests.Session()
    session.proxies = proxies
    session.headers.update({
        "User-Agent": "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/97.0.4692.71 Safari/537.36"
    })

    res = session.get(video_url)
    data_list = re.findall(r'__INITIAL_STATE__=(.+);\(function', res.text)
    data_dict = json.loads(data_list[0])
    aid = data_dict['aid']
    cid = data_dict['videoData']['cid']

    _uuid = gen_uuid()
    session.cookies.set('_uuid', _uuid)

    b_lsid = gen_b_lsid()
    session.cookies.set('b_lsid', b_lsid)

    session.cookies.set("CURRENT_FNVAL", "4048")

    res = session.get("https://api.bilibili.com/x/frontend/finger/spi")
    buvid4 = res.json()['data']['b_4']
    session.cookies.set("buvid4", buvid4)
    session.cookies.set("CURRENT_BLACKGAP", "0")
    session.cookies.set("blackside_state", "0")

    res = session.get(
        url='https://api.bilibili.com/x/player/v2',
        params={
            "cid": cid,
            "aid": aid,
            "bvid": bvid,
        }
    )

    ctime = int(time.time())
    res = session.post(
        url="https://api.bilibili.com/x/click-interface/click/web/h5",
        data={
            "aid": aid,
            "cid": cid,
            "bvid": bvid,
            "part": "1",
            "mid": "0",
            "lv": "0",
            "ftime": ctime - random.randint(100, 500),  # 浏览器首次打开时间
            "stime": ctime,
            "jsonp": "jsonp",
            "type": "3",
            "sub_type": "0",
            "from_spmid": "",
            "auto_continued_play": "0",
            "refer_url": "",
            "bsource": "",
            "spmid": ""
        }
    )

    # print(res.text)


def get_video_id_info(video_url, proxies):
    session = requests.Session()
    bvid = video_url.rsplit('/')[-1]
    res = session.get(
        url="https://api.bilibili.com/x/player/pagelist?bvid={}&jsonp=jsonp".format(bvid),
        proxies=proxies
    )

    cid = res.json()['data'][0]['cid']

    res = session.get(
        url="https://api.bilibili.com/x/web-interface/view?cid={}&bvid={}".format(cid, bvid),
        proxies=proxies
    )
    res_json = res.json()
    aid = res_json['data']['aid']
    view_count = res_json['data']['stat']['view']
    duration = res_json['data']['duration']
    print("\n视频 {}，平台播放量为：{}".format(bvid, view_count))
    session.close()
    return aid, bvid, cid, duration, int(view_count)


def run():
    proxies = get_tunnel_proxies()
    video_url = "https://www.bilibili.com/video/BV1N94y1R7K5"
    aid, bvid, cid, duration, view_count = get_video_id_info(video_url, proxies)
    while True:
        try:
            get_video_id_info(video_url, proxies)
            play(video_url, proxies)
            view_count += 1
            print("理论刷的播放量：", view_count)
        except Exception as e:
            pass


if __name__ == '__main__':
    run()
```



这段代码不是万能的，不可能拿到一个视频能让其一直刷，我们这个是匿名播放，而且视频的播放进度都是0，可能会被检测到，导致不能在刷量了。



# 代理

注册链接：`https://www.qg.net/?sale=viltf`
