# 案例

- 臧航准备网
  - 自动登录
- 爱安丘
  - 自动注册
- 油联合伙人
  - 自动登录

学习这三个案例，在学习这三个案例背后的一些知识点。通过这三个案例会发现自己不足和缺点。



# 臧航准备网

这个是航空公司内部的app，是给登录者展示航班信息，在外面市场上下载不到，不过app已经准备好了，在网盘中。

逆向之初，先使用模拟其来安装app，进行抓包分析。

## 模拟器软件

windows: 逍遥、夜神、网易mumu

## 模拟器安装

我选择**网易mumu**进行安装。电脑是windows安装前要开启vt:`https://mumu.163.com/include/16v1/2016/06/27/21967_625825.html`.只有打开了vt之后才能安装这些模拟器。



下载地址：https://mumu.163.com/index.html

安装步骤：

1.自定义安装到D盘

![image-20220818221214598](.\asset4\image-20220818221214598.png)

## 模拟器使用

进行root获取最高权限：

![image-20220818221843240](.\asset4\image-20220818221843240.png)

安装app:

- 将电脑上的apk安装包拖到模拟器中就能直接安装了

如果拖拽不能安装，说明不能自动安装，使用选择windows上的软件包来安装

![image-20220818222830906](.\asset4\image-20220818222830906.png)



## 抓包软件

浏览器上直接通过F12就能分析出请求和响应的包，但是app在模拟器上就需要用一个专门的抓包软件——charles。

- windows

  ```
  下载地址：（ charles v4.5.6，大家也可去网上自行下载和破解 ）
  注册码
  	Registered Name:  https://zhile.io
  	License Key:      48891cf209c6d32bf4
  ```

- mac

  ```
  访问网址 https://xclient.info/s/charles.html 根据提示下载并破解。
  ```


## 抓包软件和模拟器的配置

抓包软件搭配模拟器使用的原理：

![image-20220821110719046](.\asset4\image-20220821110719046.png)

1. 在抓包软件上配置代理端口
2. 在模拟器或者手机上配置代理的ip和端口
3. 手机上发送的请求会走到代理ip和端口指定的地方，也就是charles上，ip和端口会确定 一个机器上的唯一个软件，
4. charles会把请求再发送到对应服务器的地址
5. 请求响应时会是相反的，由服务器->抓包软件->设备



### 代理端口配置

将代理端口的配置改为：`9888`

![image-20220821111408680](.\asset4\image-20220821111408680.png)

配置完后，查看charles的IP地址，help->local Ip ...

![image-20220821111526362](G:\app逆向\asset4\image-20220821111526362.png)

上图表示，我的电脑上的ip是`192.168.1.2`。

这两个值用于给设备配置代理。

### SSL proxing配置

![image-20220821112016829](.\asset4\image-20220821112016829.png)



按图中的进行一下add.

### 模拟器上的配置

如果是手机，需要手机和电脑都连接上同一个路由器的无线网，两个必须在同一个网段，才能通信。模拟器默认就是在同一个网段。

1. 在模拟器中找到无线配置

![image-20220821112758264](G:\app逆向\asset4\image-20220821112758264.png)

2. 鼠标点击长按这个无线名字

![image-20220821113007189](.\asset4\image-20220821113007189.png)

3. 修改网络

![image-20220821113113360](.\asset4\image-20220821113113360.png)

4. 配置代理

![image-20220821113240098](.\asset4\image-20220821113240098.png)

5. 用之前charles的配置的端口和展示的IP进行配置

![image-20220821113421980](.\asset4\image-20220821113421980.png)

这样模拟上就设置上了代理，模拟器上发送请求时，首先会将请求发送到抓包软件上，由抓包软件再将请求发出去。

## 开始抓包（此时只能抓到http请求的包）

在模拟器中打开app，进行登录

![image-20220821114242335](G:\app逆向\asset4\image-20220821114242335.png)

可以看到，在抓包软件中抓到了登录信息

## 分析请求信息

1. 请求头分析

   没有什么特殊信息（如果有加密的数据，需要分析）

   可以加上ua

2. 请求体分析

   没有什么特殊信息

3. 请求的信息

   请求方式是post，请求url是`http://cd.tibetairlines.com.cn:9100/login`

## 用代码模拟登录这个请求

```python
import requests

headers = {
    'User-Agent': 'android_system_webview'
}
url = 'http://cd.tibetairlines.com.cn:9100/login'
data = {
    "grant_type": "password",
    "isLogin": True,
    "password": "123123",
    "username": "zxxx,F",
}
resp = requests.post(url, headers=headers, data=data)
print(resp.text)
```

输出结果是：

```
{"error":"请输入正确的用户信息登录！"}
```

和抓包工具中返回的一致，这个app的自动登录分析实现完毕

# 爱安丘

安装app后，使用抓包工具进行抓包，发现抓不到包，因为上面只配置了http请求的抓包，抓包工具抓不到https的包信息，需要对抓包工具进一步进行配置

## 配置抓取https的包（安卓7以下）

1. proxy->ssl proxying settings开始https

   ![image-20220821122843192](.\asset4\image-20220821122843192.png)

2. 查看charles证书

   ![image-20220821123310251](.\asset4\image-20220821123310251.png)

3. 模拟器上安装证书

   在模拟器中打开浏览器，输入网址，回车，会自动下载证书，证书是抓包软件提供的

   ![image-20220821123345950](.\asset4\image-20220821123345950.png)

​		在手机上先设置上代理(这步已经之前搞定了)，然后输入网址`chls.pro/ssl`，回车下载证书。

​		双击安装证书

![image-20220821124111333](.\asset4\image-20220821124111333.png)

4. 模拟器上安装好证书后，发送的https的包就可以抓到了

如果手机或者模拟器是7以下的，可以直接用上面的方式来安装证书，这样安装的证书是系统级别的证书（系统证书），如果是安卓7或者7版本以上的，上述方式是不可以的。

安卓7或7版本以上使用上述方式安装的是用户级别的证书了，因为安卓的安全性提升了，用户级别的证书是在抓包工具中抓不到包的。后续将用户级别的证书搞成系统级别的 证书就可以抓到了。真机一般都是安卓7版本以上的。

查看模拟器的安卓版本，和手机上差不多，在设置中查看

![image-20220821125049793](.\asset4\image-20220821125049793.png)

## 抓登录的包

手机中找到登录的功能：我的->登录

![image-20220821125913063](.\asset4\image-20220821125913063.png)

要输入手机号，获取验证码后，点击登录，要发送两次请求

1. 获取验证码的请求
2. 输入了验证码，登录的请求

**分析验证码请求：**

请求头：

![image-20220821131646226](.\asset4\image-20220821131646226.png)

- 请求头
  - ua的值比较特殊，和其他的不一样，请求时需要加上
  - orgid，多次请求，这个值是固定的
  - cq-agent 这个也需要加上，其中imei的值是手机的唯一id标识。
- 请求体
  - 只有一个手机号，从请求头中可以看到数据是json方式发送的
- cookie
  - orgid 和请求头中的是一样的，不变的值



imei，国际移动设备识别码，通常所说的手机序列号、手机“串号”，用于在移动电话网络中识别每一部独立的手机等移动通信设备，相当于移动电话的身份证。

可以通过代码随机生成IMEI:

```
import random
import string

# imei是十六进制的字符串，可以随机生成
def gen_imei():
    return "".join(random.choices(string.digits + 'abcdef', k=16))

imei = gen_imei()
```



验证码请求的返回值：

![image-20220821154308016](.\asset4\image-20220821154308016.png)

**登录请求分析**

请求头：

![image-20220821154451712](.\asset4\image-20220821154451712.png)

- user-agent
- orgid
- cq-agent

由`Content-Type application/json`可以知道请求体的参数是json的形式。

Cookie:

![image-20220821154637641](.\asset4\image-20220821154637641.png)

- orgid 是固定值

请求参数：

![image-20220821154714658](.\asset4\image-20220821154714658.png)

- key是请求验证码返回的响应信息中的data的值，直接使用。

## 用代码模拟获取验证码发送登录请求

```
import requests
import random
import string


def gen_imei():
    return "".join(random.choices(string.digits + 'abcdef', k=16))


imei = gen_imei()

session = requests.Session()
session.cookies.set('orgid', "137")
session.headers.update(
    {
        "cq-agent": '{"os":"android","imei":"%s","osversion":"6.0.1","network":"none","version":"0.0.28.108","core":"1.6.4"}' % imei,
        "user-agent": "chuangqi.o.137.com.iqilu.app137/0.0.28.108",
        "orgid": "137"
    }
)

phone = input('输入手机号：')

resp = session.post('https://app-auth.iqilu.com/member/phonecode', json={"phone": phone})
resp.close()
key = resp.json()['data']

check_code = input('输入验证码：')
data = {
    "phone": phone,
    "code": check_code,
    "key": key,
    "password": "",
    "captcha": "",
    "captchaKey": ""
}
resp = session.post('https://app-auth.iqilu.com/member/login', json=data)
resp.close()
print(resp.json())

```

运行结果：

![image-20220821160633342](.\asset4\image-20220821160633342.png)

可以看到成功登录了

# 油联合伙人

## 安装app并抓包分析

输入手机号和密码点击登录，在抓包工具中抓到了包

![image-20220821180648101](.\asset4\image-20220821180648101.png)

请求参数的分析：

- 手机号，我们输入的手机号
- 密码，密码进行了加密

请求头：请求头中和普通请求头不一样的地方都要携带上

![image-20220821180834780](G:\app逆向\asset4\image-20220821180834780.png)

- X-App  固定值，经过多次登录尝试，确定是固定值
- X-Noncestr 固定值
- X-OS 固定值
- X-Req-Time 时间戳，是秒级别的
- X-Sign 一段加密的字符串

分析下来，我们需要对下面两个值进行进一步分析：

1. 密码
2. X-Sign

## 反编译工具

我们手里只有apk，我们如何去看源代码？

- 需要对apk进行反编译后，就可以拿到源代码

```
apk文件，本质就是压缩包（代码）。

反编译工具，反编译成java代码，分析java代码。例如：jadx、jeb、gda。

反编译工具都依赖jre（java运行环境），直接安装JDK（包含jre）。
```

## 反编译工具安装

- 环境：需要安装JDK。
- 安装包：是免安装的，直接下载解压就行了

**JDK环境**

不要安装新的版本，很多反编译工具都要求jdk1.8

```
https://www.oracle.com/java/technologies/downloads/

# 请务必安装 JDK8==JDK1.8（后期工具需要）
https://www.oracle.com/java/technologies/downloads/#java8
```

安装时，直接下一步安装，需要记住你的环境安装到哪里了， 安装完后需要将路径添加到环境变量。

![image-20220821182819828](.\asset4\image-20220821182819828.png)

我的安装路径是：

![image-20220821183239472](.\asset4\image-20220821183239472.png)



检测是否安装成功：

![image-20220821182927206](.\asset4\image-20220821182927206.png)

**jadx**

官网下载地址：`https://github.com/skylot/jadx`

注意：代码、文件尽量不要存在中文路径，下载完解压的时候，不要放在有中文路径的文件夹下

下载解压：

![image-20220821184456086](.\asset4\image-20220821184456086.png)

我的电脑中解压到了：`D:\jadx\jadx-1.4.2`

## 使用反编译工具

打开`jadx-gui.bat`程序，将apk拖到该软件中。

拖进去后，直接就自动反编译为java代码了：

![image-20220821185421416](.\asset4\image-20220821185421416.png)

对关键字进行搜索：

![image-20220821185650611](.\asset4\image-20220821185650611.png)

搜索结果:

![image-20220821190039637](.\asset4\image-20220821190039637.png)

## 对加密进行分析

**password**

根据关键词的特点去搜索

```
password "password" password=
phone

/v1/partnerLogin/login
```

password关键字搜索出来的结果太多了，可以换一个关键字来搜索。

对url进行搜索：

![image-20220821191117229](.\asset4\image-20220821191117229.png)

可以看到只有三个结果，最后一个是我们要找的url

![image-20220821191319363](.\asset4\image-20220821191319363.png)

全局搜索函数名看哪个地方调用了，找到可疑的地方

![image-20220821191507657](.\asset4\image-20220821191507657.png)

也可以右键查找用例，来看谁调用了这个函数(可以帮我们去找，但不是百分之百能找到，没有找到可以使用搜索的方式)

![image-20220821191641128](.\asset4\image-20220821191641128.png)

只有一处调用地方：

![image-20220821191749815](.\asset4\image-20220821191749815.png)

看loginWithToken在哪里调用的

![image-20220821191926969](.\asset4\image-20220821191926969.png)

找到了两处调用的地方：

![image-20220821192236375](.\asset4\image-20220821192236375.png)

- 两处都是可疑地方，我们先分析下面的，因为看起来比较像

![image-20220821192443043](.\asset4\image-20220821192443043.png)

可以看到用的是类中的name和pwd，pwd肯定是调用了`setPwd`这个函数后才给设置的值，继续看`setPwd`函数的调用地方

![image-20220821192617154](.\asset4\image-20220821192617154.png)

可以根据名字看到是Md5进行的加密，我们可以先使用python的Md5对通用的数据进行加密尝试，如果两个加密的结果是一致的，那么就分析结束了，如果不一致，需要继续分析java代码。

进行验证：

```
from hashlib import md5

m = md5()
m.update('111222'.encode('utf-8'))
res = m.hexdigest()
print(res)  # -> 00b7691d86d96aebd21dd9e138f90840
```

python程序md5加密后的结果和请求中发送的参数中password密文是一致的，所以可以确定密码的加密就是md5.

**X-Sign**

全局搜索`X-Sign`关键字：只有一处

![image-20220821194732598](.\asset4\image-20220821194732598.png)

找`PARAM_SIGN`在哪里使用了

![image-20220821194912916](.\asset4\image-20220821194912916.png)

找到`this.sign`是在哪里赋值的

![image-20220821195151923](.\asset4\image-20220821195151923.png)

在抓包工具中的请求体的值

![image-20220821195247371](.\asset4\image-20220821195247371.png)

在看sign函数的具体实现：

![image-20220821195448451](.\asset4\image-20220821195448451.png)

sign函数中用到的变量

![image-20220821195725808](.\asset4\image-20220821195725808.png)

这里用的也是md5加密，对其进行验证测试：

```
from hashlib import md5
from urllib.parse import urlencode

headers = {
    "X-App": "native",
    "X-Noncestr": "123456",
    "X-OS": "partnerApp_android",
    "X-Req-Time": "1661076349022",
    "X-Sign": "fa825c26453f26e8860b95c3b20ee717",
    "X-Token": "",
    "X-UserID": "",
    "Host": "chinayltx.com",
    "User-Agent": "okhttp/3.10.0"
}

data = {
    "phone": "18828288222",
    "password": "00b7691d86d96aebd21dd9e138f90840"
}

encrypt_str = "{}{}{}{}".format(headers['X-Token'], headers['X-Req-Time'], headers['X-Noncestr'][2:], urlencode(data))
print(encrypt_str)

m = md5()
m.update(encrypt_str.encode('utf-8'))
res = m.hexdigest()

print(res)
# 输出结果
'''
16610763490223456phone=18828288222&password=00b7691d86d96aebd21dd9e138f90840
fa825c26453f26e8860b95c3b20ee717
'''

```

可以看到加密的字符串和请求头中的一致，至此分析结束

## 用python代码实现自动登录

```
import time
import requests
from hashlib import md5
from urllib.parse import urlencode


def gen_pwd(pwd):
    m = md5()
    m.update(pwd.encode('utf-8'))
    res = m.hexdigest()
    return res


def gen_sign(headers, data):
    encrypt_str = "{}{}{}{}".format(headers['X-Token'], headers['X-Req-Time'], headers['X-Noncestr'][2:],
                                    urlencode(data))
    print(encrypt_str)

    m = md5()
    m.update(encrypt_str.encode('utf-8'))
    res = m.hexdigest()
    return res


def login():
    phone = input('请输入手机号：')
    pwd = input('请输入密码：')
    headers = {
        "X-App": "native",
        "X-Noncestr": "123456",
        "X-OS": "partnerApp_android",
        "X-Req-Time": '{}'.format((time.time()*1000)),
        # "X-Sign": "fa825c26453f26e8860b95c3b20ee717",
        "X-Token": "",
        "X-UserID": "",
        "Host": "chinayltx.com",
        "User-Agent": "okhttp/3.10.0"
    }

    data = {
        "phone": phone,
        "password": gen_pwd(pwd)
    }
    headers['X-Sign'] = gen_sign(headers, data)

    session = requests.Session()
    session.headers = headers
    res = session.post('https://chinayltx.com/app/api/v1/partnerLogin/login', data=data)
    print(res.text)


if __name__ == '__main__':
    login()
```

运行结果：

![image-20220821205702121](.\asset4\image-20220821205702121.png)
